//Про assert и try...с catch
/*
    В этом файле попытаемся разобраться, что такое assert. Как он работает. Как его заменить на try.
    Еще разберемся в try и catch

    Работа с файлом построеная следующим образом: 
    Есть блоки кода. Они закомментированы многострочными комментариями. Нужно раскомментировать отдельные блоки и запускать программу.
    При переходе на следующий блок, придыдущий нужно комментировать.

    Начинай с функции main
*/
#include <iostream>
//assert.h нужен для assert
#include <assert.h>
//exception нужен для класса исключений exception
#include <exception>

//Используем пространство имен std
using namespace std;



//Переходи пока к main. Это нужно читать, когда дойдешь до 8 блока
//Это класс наследник от exception. Название я придумал свое. В задании к модулю 7 надо использовать другие названия для классов исключений.
//Этот класс, например, я буду использовать при неправильно переданной длинне для контейнера.
class myexcept_length : public exception {
public:
    //Конструктор по умолчанию
    myexcept_length() : exception("Unknown exception") {}
    //Параметризированный конструктор
    myexcept_length(const char *str) : exception(str) {}

    //По идеи уже этого достаточно для вывода сообщений об исключениях. Но ты можешь переопределить метод what(), добавить еще какие-то поля
};


//Переходи пока к main. Это нужно читать, когда дойдешь до 9 блока
//Это пример контейнера
class IntegerArray
{
private:
    int m_length; //длина контейнера
    int* m_data;  //массив с данными
public:
    //Конструктор по умолчанию
    IntegerArray() : m_length(0), m_data(nullptr) {}
    
    //Параметризированный конструктор
    //Ему передается длина контейнера
    IntegerArray(int length)  {
        
        /*Это пример с сайта https://www.learncpp.com/cpp-tutorial/container-classes/ 
        //ЭТОТ БЛОК КОДА РАСКОММЕНТИРОВАТЬ НЕ НАДО!!!
        //По аналогии с ним будем писать код заменяя assert(length >= 0); на if throw
        //Тут будет только  throw. try и catch будет в main функции
       
        assert(length >= 0);//Из этого видем, что length не должно быть меньще 0

        if (length > 0)
            m_data = new int[length] {};
        */

        //Пишем код
        m_length = length;
        m_data = nullptr;
        if (length < 0) {
            throw myexcept_length("Bad length!");//Выбрасываем исключение
        }

        if (length > 0) {
            //Дальше выделяем память под массив
            m_data = new int[length];
        }
    }

    //Деструктор
    ~IntegerArray() {
        delete[] m_data;
    }



};

int main(){
    //Чтобы был русский текст в консоле
    setlocale(LC_ALL, "");

   /*
   //Блок 1
   //Разберемся в каких случаях assert прервет работу программы
   assert(true);//в assert передано логическое значение true
   cout << "Это сообщение выведится" << endl;
   */
   

   /*
   //Блок 2
   //Теперь попробуем в assert передать false
   assert(false);//в assert передается логическое значение false
   cout << "Это сообщение не выведится. assert прервет выполнение программы!" << endl;
   //Значит assert прерывает выполнение программы при логическом значение false. Как это можно использовать???
   */
  

   /*
   //Блок 3
   //Теперь попробуем в assert выполнить какую-то логическую операцию
   //Объявим переменную a
   int a = 1;
   assert(a >= 0);// 1 > 0 будет true
   cout << "Этот текст выведится, если в assert будет логическое значение true. Если false программа прервется!" << endl;
   */


    /*
    //Блок 4
    //Теперь попробуем объявить a и проинициализировать другим значением
    int a = -1;
    assert(a >= 0);// -1 < 0 будет false
    cout << "Этот текст выведится, если в assert будет логическое значение true. Если false программа прервется!" << endl;
    */


    /*
    //Блок 5
    //Теперь попробуем заменить такой assert: assert(a >= 0); на блок try catch. В try выбросим простое исключение с типом int
    //Данный assert можно заменить на следующий блок try
    int a = 5;//объявим a со значением 5
    try {
        //Чтобы обработать выброшенное исключение, код должен быть помещен в блок try
        //Видно, что в assert(a >= 0) a нам нужно больше или равным нулю. Поэтому будем выбрасывать исключение в случаях, когда a меньше 0
        if (a < 0) {
            throw 9;//выбрасываем исключение типа int со значение 9
        }  
        cout << "Если условие выполнится, то это не выведится." << endl;
    }
    catch (int& e) {
        //Блок catch нужен для того, чтобы обрабатывать исключения
        //В данном catch обрабатываются исключения типа int
        cerr << "При исключении передано число: " << e << endl;//cerr похож на cout. Но в него обычно отправляются ошибки.
    }
    //Теперь нужно попробовать поменять значения для a в коде выше. Советую попробовать меньше 0.
    */

    /*
    //Блок 6
    //В try можно выбрасывать исключения разного типа. Например, добавим еще исключение типа const char*. Это строка символов.
    int a = -5;//объявим a со значением -5
    try {
        if (a < 0) {
            throw "This is exception!";//выбрасываем исключение типа строка const char*
        }
        cout << "Если условие выполнится, то это не выведится." << endl;
    }
    catch (int& e) {
        //Блок catch нужен для того, чтобы обрабатывать исключения
        //В данном catch обрабатываются исключения типа int
        cerr << "При исключении передано число: " << e << endl;//cerr похож на cout. Но в него обычно отправляются ошибки.
    }
    catch (const char *e) {
        //В данном catch обрабатываются исключения типа const char*
        cerr << "При исключении передана строка: " << e << endl;//cerr похож на cout. Но в него обычно отправляются ошибки.
    }
    //В коде выше было выброшено исключение типа строка. Это исключения обработал блок catch с типом const char *, пропустив catch с int.
    //Можно попробовать выбросить исключение типа int и посмотреть какой блок его обработает. Можно так же попробовать выбросить исключения других типов.
    //Будут ли они обрабатываться?
     */

    
    /*
    //Блок 7
    //В C++ есть класс exception. Он используется для исключений. Он служит в C++ базовым классом для других классов-исключений.
    //Попробуем выбросить объект этого типа в качестве исключения.
    int a = -5;//объявим a со значением -5
    try {
        if (a < 0) {
            throw exception("This is text exception");//выбрасываем исключение типа exception с каки-то значением
        }
        cout << "Если условие выполнится, то это не выведится." << endl;
    }
    catch (int& e) {
        //Блок catch нужен для того, чтобы обрабатывать исключения
        //В данном catch обрабатываются исключения типа int
        cerr << "При исключении передано число: " << e << endl;//cerr похож на cout. Но в него обычно отправляются ошибки.
    }
    catch (const char* e) {
        //В данном catch обрабатываются исключения типа const char*
        cerr << "При исключении передана строка: " << e << endl;
    }
    catch (exception& e) {
        //В данном catch обрабатываются исключения класса exception
        cerr << "При исключении передан объект класса exception со значением: " << e.what() << endl;//У класса exception есть метод what(), который возвращает строку с информацией
    }
    //В коде выше было выброшено исключение класса exception.
    */

    
    /*
    //Блок 8
    //В C++ есть класс можно использовать свои объекты исключения, которые являются наследнениками exception. В теории к курсу вроде было написано, что еще 
    // можно использовали обычные классы.
    //Посмотри на класс myexcept_length, описанный вверху
    int a = -5;//объявим a со значением -5
    try {
        if (a < 0) {
           throw myexcept_length("This is text myexception");//выбрасываем исключение типа myexcept_length с каки-то значением
           // throw myexcept_length(); //расскоментируй эту строку и закоментируй строку выше. Попробуй это исключение. Подумай почему такое сообщение?
        }
        cout << "Если условие выполнится, то это не выведится." << endl;
    }
    catch (myexcept_length& e) {
        //В данном catch обрабатываются исключения класса myexcept_length
        cerr << "При исключении передан объект класса myexcept_length со значением: " << e.what() << endl;
    }
    */

    /*
    //Блок 9
    //Теперь посмотрим случай, когда выбрасывается исключение в конструкторя объекта
    //Посмотри описание класса  IntegerArray вверху
    try {
        IntegerArray A(1);//попробуй отправить отрицательную длину. Почему выбросилось исключение???
        cout << "Если в конструкторе выбросится исключение, то это не выведится." << endl;
    }
    catch (myexcept_length& e) {
        //В данном catch обрабатываются исключения класса myexcept_length
        cerr << "При исключении передан объект класса myexcept_length со значением: " << e.what() << endl;
    }
    */
    
    
    /*
    //Блок 10
    //Можно перехватывать все возможные исключения с помощью Catch-all блока
    try {
        throw 9;//Попробуй повыбрасывай разного типа исключения
    }
    catch (...) {
        //В данном catch обрабатываются исключения всех типов. Это catch-all блок
        cerr << "Перехвачено исключение" << endl;
    }
    */

   return 0;
}
